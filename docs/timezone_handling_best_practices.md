## 應用程式時間處理最佳實踐：統一使用 UTC

本文件旨在闡述在應用程式中處理時間的最佳實踐，特別是關於時區的選擇。

---

您提出的問題非常關鍵，而且您的想法很直觀：既然資料來源 (氣象局 API) 和目標使用者都在台灣 (T+8)，那麼整個系統統一使用 T+8 時區似乎最簡單。這在很多專案初期都是一個非常普遍且誘人的思路。

然而，根據業界處理時間的無數血淚史和公認的最佳實踐，我會強烈建議採用另一種更健壯、更能應對未來的策略：**後端統一使用 UTC 時間，僅在最外層與使用者互動時才轉換為 T+8。**

---

### 為什麼要堅持在後端使用 UTC？

這被稱為「時區中立」(Timezone-naive) 的後端設計，有幾個無法取代的優點：

1.  **消除所有歧義**:
    UTC (世界協調時間) 是全球唯一的標準，它沒有日光節約時間。當你在資料庫看到一個 UTC 時間戳，例如 `2025-08-13 16:00:00Z`，它在地球上任何地方代表的都是同一個絕對時間點。如果存的是 `2025-08-14 00:00:00`，別人無法確定這到底是台北時間、東京時間還是倫敦時間，這會埋下無窮的隱患。

2.  **保證時間計算的正確性**:
    所有跨時區的計算、時間差的比較，都必須在一個共同的基準上進行。UTC 就是那個最完美的基準。如果你用 T+8 的時間去和一個用 T+9 (日本) 的外部服務做對接，時間計算會變得極其複雜且容易出錯。

3.  **未來擴展性與國際化**:
    雖然現在服務的都是台灣用戶，但未來呢？
    *   如果有個住在紐約的台灣人想用這個服務查詢台北天氣呢？我們應該要能顯示他當地時間的「明天」，對應到台北時間的哪個時段。
    *   如果未來要整合一個國外的服務（例如，根據天氣推薦國外旅遊地點），對方用的也一定是 UTC。
    *   **堅持使用 UTC，能讓你的服務在未來無痛接軌國際化。**

4.  **避免日光節約時間 (DST) 的天坑**:
    雖然台灣目前沒有日光節約時間，但這是軟體開發中處理時間最頭痛的問題。如果儲存的是本地時間，一旦時區規則改變（例如某年突然決定實施日光節約時間），所有歷史資料的計算都可能出錯。使用 UTC 可以完全免疫這個問題。

---

### 具體實踐建議

我會嚴格遵守「邊界轉換」原則：

1.  **資料庫層 (Database Layer)**:
    *   **現狀**: 我們在 `models.py` 中的寫法 `default=lambda: datetime.now(UTC)` **已經是正確的了**。它確保了所有 `created_at`, `updated_at` 都以 UTC 標準時間儲存。
    *   **實踐**: 對於 `start_time`, `end_time` 等業務時間，我們也應該存成 UTC。

2.  **資料獲取層 (`wea-data` service)**:
    *   當 `wea-data` 從氣象局 API 拿到 T+8 的時間字串 (例如 `"2025-08-14 00:00:00"`)。
    *   在將它存入資料庫**之前**，必須先將它**轉換成 UTC 時間**。也就是說，資料庫裡存的會是 `2025-08-13 16:00:00Z`。

3.  **資料呈現層 (`wea-mind` service)**:
    *   當 LINE Bot 需要顯示天氣時，它從資料庫讀取 UTC 時間 (`2025-08-13 16:00:00Z`)。
    *   在**最後一步**，也就是組合要傳給使用者的文字訊息時，才將這個 UTC 時間**格式化為 T+8 的時間字串** `"00:00"`。

---

### 總結

雖然「全部存 T+8」在當下看起來路徑最短，但它是一條通往混亂的捷徑。

**「後端只認 UTC，在系統邊界做時區轉換」** 是一個能讓您未來高枕無憂的黃金原則。它看起來多了一道轉換手續，但這個手續為您免去了未來無數個可能因為時區問題而產生的 Bug，絕對是值得的投資。

---

## GitHub Copilot 的額外觀點與建議

*以下為 GitHub Copilot 基於 WeaMind 專案的具體情況提供的補充意見 (2025-08-13)*

### 針對 WeaMind 專案的實用考量

雖然理論上 UTC 是最佳實踐，但我認為在這個特定專案中需要考慮以下幾個實際面向：

#### 1. **微服務架構的一致性考量**
WeaMind 有三個微服務（`wea-mind`、`wea-data`、`wea-ai`），如果每個服務都用不同的時區處理邏輯，後續整合會變得複雜。UTC 能確保所有服務間的時間基準一致，特別是在處理跨服務的時間比較時。

#### 2. **查詢邏輯的簡化**
在 `weather-query-logic.md` 中提到的滑動窗口查詢：
```sql
AND end_time > NOW()
```
如果統一使用 UTC，這個比較就是純粹的時間戳比較，不會有時區歧義。如果混用 +8，PostgreSQL 的 `NOW()` 函數和時區處理會增加複雜度。

#### 3. **實際轉換成本分析**
轉換邏輯可以封裝得很乾淨，實際開發成本並不高：

```python
# 在 wea-data 寫入時的轉換
def convert_taiwan_to_utc(taiwan_datetime_str: str) -> datetime:
    """將氣象局的台灣時間字串轉為 UTC datetime"""
    taiwan_tz = pytz.timezone('Asia/Taipei')
    taiwan_dt = datetime.strptime(taiwan_datetime_str, '%Y-%m-%d %H:%M:%S')
    taiwan_dt = taiwan_tz.localize(taiwan_dt)
    return taiwan_dt.astimezone(pytz.UTC)

# 在 wea-mind 顯示時的轉換
def format_utc_to_taiwan_time(utc_datetime: datetime) -> str:
    """將 UTC datetime 格式化為台灣時間字串"""
    taiwan_tz = pytz.timezone('Asia/Taipei')
    taiwan_dt = utc_datetime.astimezone(taiwan_tz)
    return taiwan_dt.strftime('%H:%M')
```

### 階段性實施建議

考慮到開發進度和實用性，我建議採用階段性方案：

#### 階段一：快速上線（如有時間壓力）
- 暫時全部使用台灣時間（+8）
- 確保功能正常運作
- 記錄所有時間相關的邏輯位置

#### 階段二：穩定後重構
- 系統穩定後，統一改為 UTC
- 一次性遷移所有歷史資料
- 更新所有時間處理邏輯

#### 階段三：長期維護
- 建立時區處理的標準函數庫
- 在 CI/CD 中加入時區相關的測試案例

### 最終建議

**如果這是學習專案或有急迫的上線壓力**：先用 +8，但要有計劃的重構
**如果這是要長期維護的產品**：直接使用 UTC

考慮到你的 `models.py` 已經在 `created_at`、`updated_at` 使用 UTC，為了保持一致性，業務時間欄位（`start_time`、`end_time`）也建議使用 UTC。

記住：**一開始多花點時間做對，比後面花十倍時間修 bug 要好得多。**
