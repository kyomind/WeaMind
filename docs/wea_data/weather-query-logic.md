# WeaMind 天氣資料查詢邏輯與結果分析

建立日期: 2025-08-13
更新日期: 2025-09-24
描述: WeaMind 天氣查詢的完整邏輯分析，包含資料流程、查詢策略與結果格式

## 實作狀態
✅ **weamind-data```text
🗺️ 新北市永和區

☀️ 09-12 🌡️34°💧20%
☀️ 12-15 🌡️34°💧20%
☀️ 15-18 🌡️34°💧20%
☁️ 18-21 🌡️28°💧30%

☀️ 21-00 🌡️29°💧10%
🌦️ 00-03 🌡️28°💧40%
🌦️ 03-06 🌡️27°💧70%
🌦️ 06-09 🌡️27°💧70%

09/26 11:55 更新
```運行，提供完整的天氣資料更新服務
✅ **資料庫結構**：包含完整的時間資料，涵蓋全台 368 個鄉鎮市區
✅ **查詢邏輯**：滑動窗口機制已驗證並優化

## 資料來源說明

### 資料庫內容
- **資料來源**: 氣象局開放資料平台（透過 weamind-data 微服務自動更新）
- **更新頻率**: 每日4次 (配合氣象局發布時間)
- **資料範圍**: 全台 368 個鄉鎮市區，每次更新 9 筆未來時段資料
- **時區**: 所有時間欄位為 UTC，使用時需轉換為台北時間（UTC+8）

## 使用者查詢流程 (最終方案)

此方案旨在確保使用者**任何時候都能看到完整的、未來24小時（8筆）的預報**，完美解決了因資料更新間隔導致的預報時長縮水問題。

### 場景設定
- **使用者輸入**: "新北市永和區"
- **需求**: 顯示未來15小時天氣資料

### 查詢步驟

#### 步驟1: 地點查詢
```sql
SELECT id, full_name
FROM location
WHERE full_name = '新北市永和區';

-- 結果: id = 123, full_name = '新北市永和區'
```

#### 步驟2: 最新資料查詢 (滑動窗口邏輯 + 新鮮度檢查)
```sql
SELECT
    start_time, end_time,
    weather_emoji,
    precipitation_probability,
    min_temperature, max_temperature
FROM weather
WHERE location_id = 123
  -- 1. 過濾掉已經過期的時段（注意：資料庫時間為UTC，需要轉換）
  AND end_time > NOW()
  -- 2. 確保只從最新的一批資料中選取
  AND fetched_at >= (
    SELECT MAX(fetched_at) - INTERVAL '5 minutes'
    FROM weather
    WHERE location_id = 123
  )
  -- 3. 資料新鮮度檢查：過濾掉超過 6.5 小時的舊資料
  AND fetched_at >= NOW() - INTERVAL '6.5 hours'
ORDER BY start_time
-- 4. 從剩下的有效預報中，取最前面的 8 筆
LIMIT 8;
```

**重要提醒**：查詢結果中的 `start_time` 和 `end_time` 為 UTC 時間，應用程式需要轉換為台北時間（UTC+8）再進行顯示和處理。

**查詢邏輯說明**:
1.  **過濾過期資料 (`end_time > NOW()`)**: 這是實現「滑動窗口」的關鍵。它會自動將已經結束的預報時段（如當前04:00，會過濾掉00:00-03:00的資料）排除掉。
2.  **最新批次資料 (`fetched_at` 窗口)**: 確保我們操作的資料都來自同一次、最新的更新。
3.  **資料新鮮度檢查 (`fetched_at >= NOW() - INTERVAL '6.5 hours'`)**: 防止提供過時的天氣資料，避免誤導使用者。
4.  **排序與限制 (`ORDER BY` & `LIMIT 8`)**: 從所有尚未過期的、最新批次的預報中，選取接下來的 8 個時段（24 小時）。

這個設計的巧妙之處在於，無論當前時間處於6小時更新週期的哪個點，它都能自動篩選並組合出一個完整的15小時預報，無需複雜的 `CASE` 或 `OFFSET` 邏輯。

### 資料新鮮度保證機制

為確保使用者不會收到過時的天氣資訊，WeaMind 實作了雙重保護機制：

#### 新鮮度標準
- **閾值設定**: 6.5 小時
- **設計理由**: weamind-data 微服務每 6 小時更新一次，6.5 小時的閾值提供了合理的緩衝時間，確保即使在更新延遲的情況下，也不會提供嚴重過時的資料

#### 兩個 fetched_at 條件的互補關係
1. **批次一致性條件** (`fetched_at >= MAX(fetched_at) - 5 minutes`):
   - 目的：確保所有資料來自同一次更新批次
   - 避免混合不同時間點的資料造成預報不一致

2. **絕對新鮮度條件** (`fetched_at >= NOW() - 6.5 hours`):
   - 目的：防止整批資料都過時的情況
   - 當 weamind-data 微服務長時間無法更新時，直接拒絶提供天氣資料

#### 統一錯誤處理方式
當資料不符合新鮮度要求時：
- **系統行為**: 查詢結果為空，觸發現有的錯誤處理機制
- **使用者體驗**: 收到「目前無法取得天氣資訊，請稍後再試」訊息
- **設計優勢**: 無需額外的錯誤處理邏輯，復用現有的資料缺失處理流程

## 查詢結果範例

### 資料庫查詢結果範例

基於真實資料的查詢結果（location_id = 10）：

**注意**：以下時間為 UTC，實際使用時需轉換為台北時間（+8小時）

| id   | start_time (UTC)    | end_time (UTC)      | weather_condition | emoji | precipitation | min_temp | max_temp | fetched_at (UTC)    |
| ---- | ------------------- | ------------------- | ----------------- | ----- | ------------- | -------- | -------- | ------------------- |
| 7597 | 2025-09-23 14:00:00 | 2025-09-23 17:00:00 | 陰                | ☁️     | 20            | 26       | 28       | 2025-09-23 01:46:57 |
| 7598 | 2025-09-23 17:00:00 | 2025-09-23 20:00:00 | 陰                | ☁️     | 20            | 29       | 31       | 2025-09-23 01:46:57 |
| 7599 | 2025-09-23 20:00:00 | 2025-09-23 23:00:00 | 其他              | ⛅️     | 20            | 31       | 31       | 2025-09-23 01:46:57 |
| 7600 | 2025-09-23 23:00:00 | 2025-09-24 02:00:00 | 其他              | ⛅️     | 20            | 29       | 31       | 2025-09-23 01:46:57 |
| 7601 | 2025-09-24 02:00:00 | 2025-09-24 05:00:00 | 其他              | 🌌     | 20            | 28       | 29       | 2025-09-23 01:46:57 |

### 關鍵觀察

1. **總筆數**: 查詢結果恆為 8 筆 ✅
2. **時間範圍**: 永遠是從下一個時段起算的 24 小時 ✅
3. **資料來源**: 永遠來自最新批次的9筆資料 ✅

## LINE Bot 輸出格式

### 根據 PRD v1.0 規格的最終輸出

```text
🗺️ 新北市永和區

☀️ 09-12 🌡️34°💧20%
☀️ 12-15 🌡️34°💧20%
☀️ 15-18 🌡️34°💧20%
☁️ 18-21 🌡️28°💧30%

☀️ 21-00 🌡️29°💧10%
🌦️ 00-03 🌡️28°💧40%
🌦️ 03-06 🌡️27°💧70%
🌦️ 06-09 🌡️27°💧70%

✅ 09/26 11:55 更新
```

#### Emoji 映射
2025-09-23更新：無須映射，直接使用資料庫的 `weather_emoji` 欄位，這是已經在 `weamind-data` 階段處理好的。

## 效能考量

### 查詢效能
- **單次查詢**: 1次地點查詢 + 1次天氣資料查詢
- **索引使用**: `location.full_name` 和 `weather(location_id, start_time)`
- **預期回應時間**: < 100ms
